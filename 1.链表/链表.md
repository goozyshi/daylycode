# Day1: 单链表的六大解题思路

## 21. 合并两个有序链表

[我是链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

生成一个哑节点`current`，比较`list1 `和 `list2` 指针，将`较小的值的指针`拼接在current后，current指针前进，最后`将剩余的指针全拼在current后`。

利用哑节点可以避免处理空指针的情况，减少不必要的麻烦。

```javascript
var mergeTwoLists = function(list1, list2) {
  // 生成哑节点
  let dummyNode = new ListNode(-1)
  let current = dummyNode
  while (list1 && list2) {
  	// 将较小的值的指针拼接在current后
    if (list1.val < list2.val) {
      current.next = list1
      list1 = list1.next
    } else {
      current.next = list2
      list2 = list2.next
    }
    // 指针继续前进
    current = current.next
  }
  // 将剩余的指针全拼在current后
  current.next = list1 || list2
  return dummyNode.next
};
```

## 23.合并k个链表

[我是链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

### 最小堆

由于js没有堆的数据结构，所以`将链表所有节点存入一个数组`中，再将数组`排序`，再从数组`重新生成一个完整链表`

>  优先队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，
>
>  **所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。

```js
var mergeKLists = function(lists) {
  let arr = []
  // 将所有【链表节点】存入数组，不能对lists使用flat的数组方法
  lists.map(i => {
    let node = i
    while (node) {
      arr.push(node.val)
      node = node.next
    }
  })
  // 排序
  arr.sort((a, b) => a - b)
  let dummyNode = new ListNode(-1)
  let current = dummyNode
  // 重新生成链表
  arr.map(num => {
    current.next = new ListNode(num)
    current = current.next
  })
  return dummyNode.next
};
```

### 归并合并排序链表

输入k个排序链表，将其拆分成`前k/2个链表`和后`k/2个链表`，这前k/2个链表和后k/2个链表`分别合并成两个排序的链表`，再将两个排序的链表合并，所有链表就都合并了。

> - 下面代码中递归调用栈的深度为O(logn)，所以空间复杂度为**O(logn)**
> - 因为使用的是归并排序的思路，所以它的时间复杂度为**O(nlogn)**

```javascript
var mergeKLists = function(lists) {
  if (!lists.length) {
    return null
  }
  /* 合并两个链表为升序链表 */
  var mergeTwoLists = function(list1, list2) {
    // 生成哑节点
    let dummyNode = new ListNode(-1)
    let current = dummyNode
    while (list1 && list2) {
      // 将较小的值的指针拼接在current后
      if (list1.val < list2.val) {
        current.next = list1
        list1 = list1.next
      } else {
        current.next = list2
        list2 = list2.next
      }
      // 指针继续前进
      current = current.next
    }
    // 将剩余的指针全拼在current后
    current.next = list1 || list2
    return dummyNode.next
  };
  const mergeLists = (lists, start = 0, end = lists.length) => {
    // 仅有一个节点时直接返回 lists， 无需拆分
    if (start + 1 === end) {
      return lists[start]
    }
    // 拆分成两个链表，分别进行排序
    const mid = Math.floor((start + end)/2) // 也可写作 const mid = (start + end) >> 1
    const l1 = mergeLists(lists, start, mid)
    const l2 = mergeLists(lists, mid, end)
    return mergeTwoLists(l1, l2)
  }
  // 前闭后开区间
  return mergeLists(lists, 0, lists.length)
};
```



## 19.删除链表的倒数第 N 个结点

[我是链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

生成哑结点，让`快指针先走N步`，快指针到达时，慢指针到达倒数N + 1结点处，再删除

```js
var removeNthFromEnd = function(head, n) {
  let dummyNode = new ListNode(-1)
  dummyNode.next = head
  let fast = dummyNode
  let slow = dummyNode
  // 快指针先走 N 步
  while (n --) {
    fast = fast.next
  }
  // 快指针到达终点，慢指针到达倒数N + 1处
  while (fast && fast.next) {
    fast = fast.next
    slow = slow.next
  }
  // 删除
  slow.next = slow.next.next
  return dummyNode.next
};
```

## 876. 链表的中间结点

[我是链接](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

设置快慢指针，让快指针速度是慢指针的2倍，快指针到达时，慢指针刚好在链表中点。

```javascript
var middleNode = function(head) {
  let slow = fast = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
  }
  return slow
};
```

## 环形链表II - 环位置

[我是链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

设置快(2)慢(1)指针，若`快慢指针相遇，则为环形`

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以`相同速度`前进，再次相遇时所在的节点位置就是`环开始的位置`

```js
var detectCycle = function(head) {
  let slow = head
  let fast = head
  let isLoop = false
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (slow === fast) {
      // 快慢指针相遇，则为环形
      isLoop = true
      // 跳出循环
      break
    }
  }
  // 确认是环形，找出pos
  if (isLoop) {
    slow = head
    while (slow !== fast) {
      slow = slow.next
      fast = fast.next
    }
  }
  return isLoop ? slow : null
};
```

## 160. 相交链表

[我是链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，

让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，

这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点

```js

var getIntersectionNode = function(headA, headB) {
  let p1 = headA
  let p2 = headB
  while (p1 != p2) {
    // 遍历完后遍历另一支链表
    p1 = p1 ? p1.next : headB
    p2 = p2 ? p2.next : headA
  }
  return p1
};
```

# Day2: 递归反转链表

## 206. 反转整个链表

[我是链接](https://leetcode-cn.com/problems/reverse-linked-list/)

### 递归



将递归函数定义为：输入一个结点head，`将以【head为起点】的链表反转，返回反转后的头节点`.

递归函数需要base case，当`链表仅有一个节点时，反转后也是自己`，直接返回即可

```js
var reverseList = function(head) {
  // 链表仅有一个节点，直接返回
  if (head === null || head.next === null) {
    return head
  }
  // 将head.next为起点的链表反转，返回反转后的头结点
  const last = reverseList(head.next)
  head.next.next = head
  head.next = null
  return last
};
```

### 迭代

![img](https://pic.leetcode-cn.com/1624782858-oyJziv-008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

```js
var reverseList = function(head) {
  let pre = null
  let current = head
  while (current) {
    // 临时变量存储未反转的链表起点
    const temp = current.next
    current.next = pre
    pre = current
    current = temp
  }
  return pre
};
```

## 反转链表的前n个节点

递归函数定义： 反转`以head为起点的前n个节点`链表，返回反转后的头节点

basecase:

```js
/**
* A -> B -> C -> D
* A <- B C -> D
* A -> C
*/
let rest = null
var reverseN = function(head, n) {
  if (n === 1) {
    // 返回当前节点
    // 并记录 n + 1 的节点位置（未反转部分的链表起点）
    rest = head.next
    return head
  }
  // 反转 head.next 为起点的 n - 1 个节点
	const last = reverseN(head.next, n - 1)
  head.next.next = head
  // 反转后的节点和未反转的节点连接起来
  head.next = rest
  return last
};
```



## 92.反转链表的一部分节点

[我是链接](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

basecase：当 left 为 1 时，相当于**反转前N个节点**。

反转head起始的[left，right]区间就相当于反转 head.next 起始的[left - 1, right - 1]区间

```js
var reverseBetween = function(head, left, right) {
  if (left === 1) {
    return revereN(head, right)
  }
  // 以 head.next 为下标 1，那就是 反转head.next为起点的 left - 1, right - 1 区间
  head.next = reverseBetween(head.next, left - 1, right - 1)
  return head
};

// 反转前 N 个链表，相当于 left = 1 开始
let rest = null
const revereN = (head, n) => {
  if (n === 1) {
    rest = head.next
    return head
  }
  const last = revereN(head.next, n - 1)
  head.next.next = head
  head.next = rest
  return last
}
```



## 25. K个一组反转链表

[我是链接](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

记录下每k个一组的起始节点和结束节点，不足 k 个的直接返回head。

将反转`起始节点和结束节点的链表`并拼接到`剩余未反转的链表`上

```js
var reverseKGroup = function(head, k) {
  // 用start 和 end 记录每k个需要反转的起始节点、结束起点
  let start = end = head
  // 不足 k 个即end 到达了 null，直接返回 head
  for (let i = 0; i < k; i ++) {
    if (end === null) {
      return head
    }
    // 得到第 k 个节点 end
    end = end.next
  }
  // 反转 start 到 end 间的链表
  const last = reverse(start, end)
  start.next = reverseKGroup(end, k)
  return last
};

// 前面的反转整个链表：其实就是反转 head 到 null 间的链表
// 迭代
const reverse = (start, end = null) => {
  let pre = null
  let current = start
  while (current !== end) {
    const temp = current.next
    current.next = pre
    pre = current
    current = temp
  }
  return pre
}
```

## 234.回文链表

[我是链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

找出中点，将中点后的节点反转，记录为右指针，比较左指针（起始）和右指针的节点值，不同则返回false

```js

//  反转链表
 const reverse = (head) => {
   if (head === null || head.next == null) {
     return head
   }
   const last = reverse(head.next)
   head.next.next = head
   head.next = null
   return last
 }
var isPalindrome = function(head) {
  // 找出中点
  let fast = slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
  }
  // 注意奇数链表，中点多走一步
  if (fast !== null) {
    slow = slow.next
  }
  let left = head
  let right = reverse(slow)
  while (right) {
    if (left.val != right.val) {
      return false
    }
    left = left.next
    right = right.next
  }
  return true
};
```